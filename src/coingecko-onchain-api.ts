/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * On-Chain DEX API (Beta)
 * OpenAPI spec version: v2-beta
 */
import { request } from "./fetch";
export type OnchainSimplePriceDataAttributesTokenPrices = {
  [key: string]: string;
};

export type OnchainSimplePriceDataAttributes = {
  token_prices?: OnchainSimplePriceDataAttributesTokenPrices;
};

export type OnchainSimplePriceData = {
  id?: string;
  type?: string;
  attributes?: OnchainSimplePriceDataAttributes;
};

export interface OnchainSimplePrice {
  data?: OnchainSimplePriceData;
}

export type NetworksListDataItemAttributes = {
  name?: string;
  coingecko_asset_platform_id?: string;
};

export type NetworksListDataItem = {
  id?: string;
  type?: string;
  attributes?: NetworksListDataItemAttributes;
};

export interface NetworksList {
  data?: NetworksListDataItem[];
}

export type DexesListDataItemAttributes = {
  name?: string;
};

export type DexesListDataItem = {
  id?: string;
  type?: string;
  attributes?: DexesListDataItemAttributes;
};

export interface DexesList {
  data?: DexesListDataItem[];
}

export type PoolDataItemAttributesPriceChangePercentage = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type PoolDataItemAttributesTransactionsM5 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolDataItemAttributesTransactionsM15 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolDataItemAttributesTransactionsM30 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolDataItemAttributesTransactionsH1 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolDataItemAttributesTransactionsH24 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolDataItemAttributesTransactions = {
  m5?: PoolDataItemAttributesTransactionsM5;
  m15?: PoolDataItemAttributesTransactionsM15;
  m30?: PoolDataItemAttributesTransactionsM30;
  h1?: PoolDataItemAttributesTransactionsH1;
  h24?: PoolDataItemAttributesTransactionsH24;
};

export type PoolDataItemAttributesVolumeUsd = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type PoolDataItemAttributes = {
  base_token_price_usd?: string;
  base_token_price_native_currency?: string;
  quote_token_price_usd?: string;
  quote_token_price_native_currency?: string;
  base_token_price_quote_token?: string;
  quote_token_price_base_token?: string;
  address?: string;
  name?: string;
  pool_created_at?: string;
  fdv_usd?: string;
  market_cap_usd?: string;
  price_change_percentage?: PoolDataItemAttributesPriceChangePercentage;
  transactions?: PoolDataItemAttributesTransactions;
  volume_usd?: PoolDataItemAttributesVolumeUsd;
  reserve_in_usd?: string;
};

export type PoolDataItemRelationshipsBaseTokenData = {
  id?: string;
  type?: string;
};

export type PoolDataItemRelationshipsBaseToken = {
  data?: PoolDataItemRelationshipsBaseTokenData;
};

export type PoolDataItemRelationshipsQuoteTokenData = {
  id?: string;
  type?: string;
};

export type PoolDataItemRelationshipsQuoteToken = {
  data?: PoolDataItemRelationshipsQuoteTokenData;
};

export type PoolDataItemRelationshipsNetworkData = {
  id?: string;
  type?: string;
};

export type PoolDataItemRelationshipsNetwork = {
  data?: PoolDataItemRelationshipsNetworkData;
};

export type PoolDataItemRelationshipsDexData = {
  id?: string;
  type?: string;
};

export type PoolDataItemRelationshipsDex = {
  data?: PoolDataItemRelationshipsDexData;
};

export type PoolDataItemRelationships = {
  base_token?: PoolDataItemRelationshipsBaseToken;
  quote_token?: PoolDataItemRelationshipsQuoteToken;
  network?: PoolDataItemRelationshipsNetwork;
  dex?: PoolDataItemRelationshipsDex;
};

export type PoolDataItem = {
  id?: string;
  type?: string;
  attributes?: PoolDataItemAttributes;
  relationships?: PoolDataItemRelationships;
};

export type PoolIncludedItemAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  decimals?: number;
  image_url?: string;
  coingecko_coin_id?: string;
};

export type PoolIncludedItem = {
  id?: string;
  type?: string;
  attributes?: PoolIncludedItemAttributes;
};

export interface Pool {
  data?: PoolDataItem[];
  included?: PoolIncludedItem[];
}

export type PoolInfoDataItemAttributesPriceChangePercentage = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type PoolInfoDataItemAttributesTransactionsM5 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactionsM15 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactionsM30 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactionsH1 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactionsH6 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactionsH24 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type PoolInfoDataItemAttributesTransactions = {
  m5?: PoolInfoDataItemAttributesTransactionsM5;
  m15?: PoolInfoDataItemAttributesTransactionsM15;
  m30?: PoolInfoDataItemAttributesTransactionsM30;
  h1?: PoolInfoDataItemAttributesTransactionsH1;
  h6?: PoolInfoDataItemAttributesTransactionsH6;
  h24?: PoolInfoDataItemAttributesTransactionsH24;
};

export type PoolInfoDataItemAttributesVolumeUsd = {
  m5?: string;
  m15?: string;
  m30?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type PoolInfoDataItemAttributes = {
  base_token_price_usd?: string;
  base_token_price_native_currency?: string;
  quote_token_price_usd?: string;
  quote_token_price_native_currency?: string;
  base_token_price_quote_token?: string;
  quote_token_price_base_token?: string;
  address?: string;
  name?: string;
  pool_created_at?: string;
  fdv_usd?: string;
  market_cap_usd?: string;
  price_change_percentage?: PoolInfoDataItemAttributesPriceChangePercentage;
  transactions?: PoolInfoDataItemAttributesTransactions;
  volume_usd?: PoolInfoDataItemAttributesVolumeUsd;
  reserve_in_usd?: string;
  locked_liquidity_percentage?: string;
};

export type PoolInfoDataItemRelationshipsBaseTokenData = {
  id?: string;
  type?: string;
};

export type PoolInfoDataItemRelationshipsBaseToken = {
  data?: PoolInfoDataItemRelationshipsBaseTokenData;
};

export type PoolInfoDataItemRelationshipsQuoteTokenData = {
  id?: string;
  type?: string;
};

export type PoolInfoDataItemRelationshipsQuoteToken = {
  data?: PoolInfoDataItemRelationshipsQuoteTokenData;
};

export type PoolInfoDataItemRelationshipsDexData = {
  id?: string;
  type?: string;
};

export type PoolInfoDataItemRelationshipsDex = {
  data?: PoolInfoDataItemRelationshipsDexData;
};

export type PoolInfoDataItemRelationships = {
  base_token?: PoolInfoDataItemRelationshipsBaseToken;
  quote_token?: PoolInfoDataItemRelationshipsQuoteToken;
  dex?: PoolInfoDataItemRelationshipsDex;
};

export type PoolInfoDataItem = {
  id?: string;
  type?: string;
  attributes?: PoolInfoDataItemAttributes;
  relationships?: PoolInfoDataItemRelationships;
};

export type PoolInfoIncludedItemAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  decimals?: number;
  image_url?: string;
  coingecko_coin_id?: string;
};

export type PoolInfoIncludedItem = {
  id?: string;
  type?: string;
  attributes?: PoolInfoIncludedItemAttributes;
};

export interface PoolInfo {
  data?: PoolInfoDataItem[];
  included?: PoolInfoIncludedItem[];
}

export type TrendingPoolsDataItemAttributesVolumeUsd = {
  h24?: string;
};

export type TrendingPoolsDataItemAttributes = {
  trending_rank?: number;
  address?: string;
  name?: string;
  pool_created_at?: string;
  fdv_usd?: string;
  market_cap_usd?: string;
  volume_usd?: TrendingPoolsDataItemAttributesVolumeUsd;
  reserve_in_usd?: string;
};

export type TrendingPoolsDataItemRelationshipsNetworkData = {
  id?: string;
  type?: string;
};

export type TrendingPoolsDataItemRelationshipsNetwork = {
  data?: TrendingPoolsDataItemRelationshipsNetworkData;
};

export type TrendingPoolsDataItemRelationshipsDexData = {
  id?: string;
  type?: string;
};

export type TrendingPoolsDataItemRelationshipsDex = {
  data?: TrendingPoolsDataItemRelationshipsDexData;
};

export type TrendingPoolsDataItemRelationshipsBaseTokenData = {
  id?: string;
  type?: string;
};

export type TrendingPoolsDataItemRelationshipsBaseToken = {
  data?: TrendingPoolsDataItemRelationshipsBaseTokenData;
};

export type TrendingPoolsDataItemRelationshipsQuoteTokenData = {
  id?: string;
  type?: string;
};

export type TrendingPoolsDataItemRelationshipsQuoteToken = {
  data?: TrendingPoolsDataItemRelationshipsQuoteTokenData;
};

export type TrendingPoolsDataItemRelationships = {
  network?: TrendingPoolsDataItemRelationshipsNetwork;
  dex?: TrendingPoolsDataItemRelationshipsDex;
  base_token?: TrendingPoolsDataItemRelationshipsBaseToken;
  quote_token?: TrendingPoolsDataItemRelationshipsQuoteToken;
};

export type TrendingPoolsDataItem = {
  id?: string;
  type?: string;
  attributes?: TrendingPoolsDataItemAttributes;
  relationships?: TrendingPoolsDataItemRelationships;
};

export type TrendingPoolsIncludedItemAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  decimals?: number;
  image_url?: string;
  coingecko_coin_id?: string;
};

export type TrendingPoolsIncludedItem = {
  id?: string;
  type?: string;
  attributes?: TrendingPoolsIncludedItemAttributes;
};

export interface TrendingPools {
  data?: TrendingPoolsDataItem[];
  included?: TrendingPoolsIncludedItem[];
}

export type TokenDataAttributesVolumeUsd = {
  h24?: string;
};

export type TokenDataAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  image_url?: string;
  coingecko_coin_id?: string;
  decimals?: number;
  total_supply?: string;
  price_usd?: string;
  fdv_usd?: string;
  total_reserve_in_usd?: string;
  volume_usd?: TokenDataAttributesVolumeUsd;
  market_cap_usd?: string;
};

export type TokenDataRelationshipsTopPoolsDataItem = {
  id?: string;
  type?: string;
};

export type TokenDataRelationshipsTopPools = {
  data?: TokenDataRelationshipsTopPoolsDataItem[];
};

export type TokenDataRelationships = {
  top_pools?: TokenDataRelationshipsTopPools;
};

export type TokenData = {
  id?: string;
  type?: string;
  attributes?: TokenDataAttributes;
  relationships?: TokenDataRelationships;
};

export type TokenIncludedItemAttributesPriceChangePercentage = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type TokenIncludedItemAttributesTransactionsM5 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type TokenIncludedItemAttributesTransactionsM15 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type TokenIncludedItemAttributesTransactionsM30 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type TokenIncludedItemAttributesTransactionsH1 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type TokenIncludedItemAttributesTransactionsH24 = {
  buys?: number;
  sells?: number;
  buyers?: number;
  sellers?: number;
};

export type TokenIncludedItemAttributesTransactions = {
  m5?: TokenIncludedItemAttributesTransactionsM5;
  m15?: TokenIncludedItemAttributesTransactionsM15;
  m30?: TokenIncludedItemAttributesTransactionsM30;
  h1?: TokenIncludedItemAttributesTransactionsH1;
  h24?: TokenIncludedItemAttributesTransactionsH24;
};

export type TokenIncludedItemAttributesVolumeUsd = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type TokenIncludedItemAttributes = {
  base_token_price_usd?: string;
  base_token_price_native_currency?: string;
  quote_token_price_usd?: string;
  quote_token_price_native_currency?: string;
  base_token_price_quote_token?: string;
  quote_token_price_base_token?: string;
  address?: string;
  name?: string;
  pool_created_at?: string;
  token_price_usd?: string;
  fdv_usd?: string;
  market_cap_usd?: string;
  price_change_percentage?: TokenIncludedItemAttributesPriceChangePercentage;
  transactions?: TokenIncludedItemAttributesTransactions;
  volume_usd?: TokenIncludedItemAttributesVolumeUsd;
  reserve_in_usd?: string;
};

export type TokenIncludedItemRelationshipsBaseTokenData = {
  id?: string;
  type?: string;
};

export type TokenIncludedItemRelationshipsBaseToken = {
  data?: TokenIncludedItemRelationshipsBaseTokenData;
};

export type TokenIncludedItemRelationshipsQuoteTokenData = {
  id?: string;
  type?: string;
};

export type TokenIncludedItemRelationshipsQuoteToken = {
  data?: TokenIncludedItemRelationshipsQuoteTokenData;
};

export type TokenIncludedItemRelationshipsDexData = {
  id?: string;
  type?: string;
};

export type TokenIncludedItemRelationshipsDex = {
  data?: TokenIncludedItemRelationshipsDexData;
};

export type TokenIncludedItemRelationships = {
  base_token?: TokenIncludedItemRelationshipsBaseToken;
  quote_token?: TokenIncludedItemRelationshipsQuoteToken;
  dex?: TokenIncludedItemRelationshipsDex;
};

export type TokenIncludedItem = {
  id?: string;
  type?: string;
  attributes?: TokenIncludedItemAttributes;
  relationships?: TokenIncludedItemRelationships;
};

export interface Token {
  data?: TokenData;
  included?: TokenIncludedItem[];
}

export type TokenInfoDataAttributesGtScoreDetails = {
  pool?: number;
  transaction?: number;
  creation?: number;
  info?: number;
  holders?: number;
};

export type TokenInfoDataAttributesHoldersDistributionPercentage = {
  top_10?: number;
  "11_30"?: number;
  "31_50"?: number;
  rest?: number;
};

export type TokenInfoDataAttributesHolders = {
  count?: number;
  distribution_percentage?: TokenInfoDataAttributesHoldersDistributionPercentage;
  last_updated?: string;
};

export type TokenInfoDataAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  image_url?: string;
  coingecko_coin_id?: string;
  websites?: string[];
  description?: string;
  gt_score?: number;
  gt_score_details?: TokenInfoDataAttributesGtScoreDetails;
  discord_url?: string;
  telegram_handle?: string;
  twitter_handle?: string;
  categories?: string[];
  gt_categories_id?: string[];
  holders?: TokenInfoDataAttributesHolders;
  mint_authority?: string;
  freeze_authority?: string;
};

export type TokenInfoData = {
  id?: string;
  type?: string;
  attributes?: TokenInfoDataAttributes;
};

export interface TokenInfo {
  data?: TokenInfoData;
}

export type TokenHolderDataAttributesHoldersItem = {
  rank?: number;
  address?: string;
  label?: string;
  amount?: string;
  percentage?: string;
  value?: string;
};

export type TokenHolderDataAttributes = {
  last_updated_at?: string;
  holders?: TokenHolderDataAttributesHoldersItem[];
};

export type TokenHolderData = {
  id?: string;
  type?: string;
  attributes?: TokenHolderDataAttributes;
};

export interface TokenHolder {
  data?: TokenHolderData;
}

export type PoolTokensInfo = TokenInfo;

export type TokenInfoRecentlyUpdated = TokenInfo;

export type OhlcvDataAttributes = {
  ohlcv_list?: number[][];
};

export type OhlcvData = {
  id?: string;
  type?: string;
  attributes?: OhlcvDataAttributes;
};

export type OhlcvMetaBase = {
  address?: string;
  name?: string;
  symbol?: string;
  coingecko_coin_id?: string;
};

export type OhlcvMetaQuote = {
  address?: string;
  name?: string;
  symbol?: string;
  coingecko_coin_id?: string;
};

export type OhlcvMeta = {
  base?: OhlcvMetaBase;
  quote?: OhlcvMetaQuote;
};

export interface Ohlcv {
  data?: OhlcvData;
  meta?: OhlcvMeta;
}

export type TradesDataItemAttributes = {
  block_number?: number;
  tx_hash?: string;
  tx_from_address?: string;
  from_token_amount?: string;
  to_token_amount?: string;
  price_from_in_currency_token?: string;
  price_to_in_currency_token?: string;
  price_from_in_usd?: string;
  price_to_in_usd?: string;
  block_timestamp?: string;
  kind?: string;
  volume_in_usd?: string;
  from_token_address?: string;
  to_token_address?: string;
};

export type TradesDataItem = {
  id?: string;
  type?: string;
  attributes?: TradesDataItemAttributes;
};

export interface Trades {
  data?: TradesDataItem[];
}

export type OnchainCategoriesListDataItemAttributesVolumeChangePercentage = {
  h1?: string;
  h6?: string;
  h12?: string;
  h24?: string;
};

export type OnchainCategoriesListDataItemAttributes = {
  name?: string;
  description?: string;
  volume_change_percentage?: OnchainCategoriesListDataItemAttributesVolumeChangePercentage;
  reserve_in_usd?: string;
  fdv_usd?: string;
  h24_volume_usd?: string;
  h24_tx_count?: number;
};

export type OnchainCategoriesListDataItem = {
  id?: string;
  type?: string;
  attributes?: OnchainCategoriesListDataItemAttributes;
};

export interface OnchainCategoriesList {
  data?: OnchainCategoriesListDataItem[];
}

export type CategoriesPoolsDataItemAttributesPriceChangePercentage = {
  m5?: string;
  h1?: string;
  h6?: string;
  h24?: string;
};

export type CategoriesPoolsDataItemAttributes = {
  base_token_price_usd?: string;
  base_token_price_native_currency?: string;
  quote_token_price_usd?: string;
  quote_token_price_native_currency?: string;
  base_token_price_quote_token?: string;
  quote_token_price_base_token?: string;
  address?: string;
  name?: string;
  pool_created_at?: string;
  /** @nullable */
  fdv_usd?: string | null;
  /** @nullable */
  market_cap_usd?: string | null;
  price_change_percentage?: CategoriesPoolsDataItemAttributesPriceChangePercentage;
  reserve_in_usd?: string;
  h24_volume_usd?: string;
  h24_tx_count?: number;
};

export type CategoriesPoolsDataItemRelationshipsNetworkData = {
  id?: string;
  type?: string;
};

export type CategoriesPoolsDataItemRelationshipsNetwork = {
  data?: CategoriesPoolsDataItemRelationshipsNetworkData;
};

export type CategoriesPoolsDataItemRelationshipsDexData = {
  id?: string;
  type?: string;
};

export type CategoriesPoolsDataItemRelationshipsDex = {
  data?: CategoriesPoolsDataItemRelationshipsDexData;
};

export type CategoriesPoolsDataItemRelationshipsBaseTokenData = {
  id?: string;
  type?: string;
};

export type CategoriesPoolsDataItemRelationshipsBaseToken = {
  data?: CategoriesPoolsDataItemRelationshipsBaseTokenData;
};

export type CategoriesPoolsDataItemRelationshipsQuoteTokenData = {
  id?: string;
  type?: string;
};

export type CategoriesPoolsDataItemRelationshipsQuoteToken = {
  data?: CategoriesPoolsDataItemRelationshipsQuoteTokenData;
};

export type CategoriesPoolsDataItemRelationships = {
  network?: CategoriesPoolsDataItemRelationshipsNetwork;
  dex?: CategoriesPoolsDataItemRelationshipsDex;
  base_token?: CategoriesPoolsDataItemRelationshipsBaseToken;
  quote_token?: CategoriesPoolsDataItemRelationshipsQuoteToken;
};

export type CategoriesPoolsDataItem = {
  id?: string;
  type?: string;
  attributes?: CategoriesPoolsDataItemAttributes;
  relationships?: CategoriesPoolsDataItemRelationships;
};

export type CategoriesPoolsIncludedItemAttributes = {
  address?: string;
  name?: string;
  symbol?: string;
  decimals?: number;
  image_url?: string;
  /** @nullable */
  coingecko_coin_id?: string | null;
};

export type CategoriesPoolsIncludedItem = {
  id?: string;
  type?: string;
  attributes?: CategoriesPoolsIncludedItemAttributes;
};

export interface CategoriesPools {
  data?: CategoriesPoolsDataItem[];
  included?: CategoriesPoolsIncludedItem[];
}

export type OnchainSimplePriceParams = {
  /**
   * include market capitalization, default: false
   */
  include_market_cap?: boolean;
  /**
   * return FDV if market cap is not available, default: false
   */
  mcap_fdv_fallback?: boolean;
  /**
   * include 24hr volume, default: false
   */
  include_24hr_vol?: boolean;
  /**
   * include 24hr price change, default: false
   */
  include_24hr_price_change?: boolean;
  /**
   * include total reserve in USD, default: false
   */
  include_total_reserve_in_usd?: boolean;
};

export type NetworksListParams = {
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
};

export type DexesListParams = {
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
};

export type TrendingPoolsListParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * duration to sort trending list by <br> Default value: 24h
   */
  duration?: TrendingPoolsListDuration;
};

export type TrendingPoolsListDuration =
  (typeof TrendingPoolsListDuration)[keyof typeof TrendingPoolsListDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrendingPoolsListDuration = {
  "5m": "5m",
  "1h": "1h",
  "6h": "6h",
  "24h": "24h",
} as const;

export type TrendingPoolsNetworkParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * duration to sort trending list by <br> Default value: 24h
   */
  duration?: TrendingPoolsNetworkDuration;
};

export type TrendingPoolsNetworkDuration =
  (typeof TrendingPoolsNetworkDuration)[keyof typeof TrendingPoolsNetworkDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrendingPoolsNetworkDuration = {
  "5m": "5m",
  "1h": "1h",
  "6h": "6h",
  "24h": "24h",
} as const;

export type PoolAddressParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
};

export type PoolsAddressesParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
};

export type TopPoolsNetworkParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * sort the pools by field <br> Default value: h24_tx_count_desc
   */
  sort?: TopPoolsNetworkSort;
};

export type TopPoolsNetworkSort =
  (typeof TopPoolsNetworkSort)[keyof typeof TopPoolsNetworkSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TopPoolsNetworkSort = {
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
} as const;

export type TopPoolsDexParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * sort the pools by field <br> Default value: h24_tx_count_desc
   */
  sort?: TopPoolsDexSort;
};

export type TopPoolsDexSort =
  (typeof TopPoolsDexSort)[keyof typeof TopPoolsDexSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TopPoolsDexSort = {
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
} as const;

export type LatestPoolsNetworkParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
};

export type LatestPoolsListParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
};

export type PoolsMegafilterParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)
   */
  networks?: string;
  /**
   * filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)
   */
  dexes?: string;
  /**
   * sort the pools by field <br> Default value: h6_trending
   */
  sort?: PoolsMegafilterSort;
  /**
   * minimum fully diluted value in USD
   */
  fdv_usd_min?: number;
  /**
   * maximum fully diluted value in USD
   */
  fdv_usd_max?: number;
  /**
   * minimum reserve in USD
   */
  reserve_in_usd_min?: number;
  /**
   * maximum reserve in USD
   */
  reserve_in_usd_max?: number;
  /**
   * minimum 24hr volume in USD
   */
  h24_volume_usd_min?: number;
  /**
   * maximum 24hr volume in USD
   */
  h24_volume_usd_max?: number;
  /**
   * minimum pool age in hours
   */
  pool_created_hour_min?: number;
  /**
   * maximum pool age in hours
   */
  pool_created_hour_max?: number;
  /**
   * minimum transaction count
   */
  tx_count_min?: number;
  /**
   * maximum transaction count
   */
  tx_count_max?: number;
  /**
   * duration for transaction count metric <br> Default value: 24h
   */
  tx_count_duration?: PoolsMegafilterTxCountDuration;
  /**
   * minimum number of buy transactions
   */
  buys_min?: number;
  /**
   * maximum number of buy transactions
   */
  buys_max?: number;
  /**
   * duration for buy transactions metric <br> Default value: 24h
   */
  buys_duration?: PoolsMegafilterBuysDuration;
  /**
   * minimum number of sell transactions
   */
  sells_min?: number;
  /**
   * maximum number of sell transactions
   */
  sells_max?: number;
  /**
   * duration for sell transactions metric <br> Default value: 24h
   */
  sells_duration?: PoolsMegafilterSellsDuration;
  /**
   * filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`
   */
  checks?: string;
  /**
   * minimum buy tax percentage
   */
  buy_tax_percentage_min?: number;
  /**
   * maximum buy tax percentage
   */
  buy_tax_percentage_max?: number;
  /**
   * minimum sell tax percentage
   */
  sell_tax_percentage_min?: number;
  /**
   * maximum sell tax percentage
   */
  sell_tax_percentage_max?: number;
};

export type PoolsMegafilterSort =
  (typeof PoolsMegafilterSort)[keyof typeof PoolsMegafilterSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolsMegafilterSort = {
  m5_trending: "m5_trending",
  h1_trending: "h1_trending",
  h6_trending: "h6_trending",
  h24_trending: "h24_trending",
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
  h24_price_change_percentage_desc: "h24_price_change_percentage_desc",
  pool_created_at_desc: "pool_created_at_desc",
} as const;

export type PoolsMegafilterTxCountDuration =
  (typeof PoolsMegafilterTxCountDuration)[keyof typeof PoolsMegafilterTxCountDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolsMegafilterTxCountDuration = {
  "5m": "5m",
  "1h": "1h",
  "6h": "6h",
  "24h": "24h",
} as const;

export type PoolsMegafilterBuysDuration =
  (typeof PoolsMegafilterBuysDuration)[keyof typeof PoolsMegafilterBuysDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolsMegafilterBuysDuration = {
  "5m": "5m",
  "1h": "1h",
  "6h": "6h",
  "24h": "24h",
} as const;

export type PoolsMegafilterSellsDuration =
  (typeof PoolsMegafilterSellsDuration)[keyof typeof PoolsMegafilterSellsDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolsMegafilterSellsDuration = {
  "5m": "5m",
  "1h": "1h",
  "6h": "6h",
  "24h": "24h",
} as const;

export type SearchPoolsParams = {
  /**
   * search query
   */
  query?: string;
  /**
   * network ID <br> *refers to [/networks](/reference/networks-list)
   */
  network?: string;
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
};

export type TrendingSearchPoolsParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
   */
  include?: string;
  /**
   * number of pools to return, maximum 10 <br> Default value: 4
   */
  pools?: number;
};

export type TopPoolsContractAddressParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: 1
   */
  page?: number;
  /**
   * sort the pools by field <br> Default value: h24_volume_usd_liquidity_desc
   */
  sort?: TopPoolsContractAddressSort;
};

export type TopPoolsContractAddressSort =
  (typeof TopPoolsContractAddressSort)[keyof typeof TopPoolsContractAddressSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TopPoolsContractAddressSort = {
  h24_volume_usd_liquidity_desc: "h24_volume_usd_liquidity_desc",
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
} as const;

export type TokenDataContractAddressParams = {
  /**
   * attributes to include
   */
  include?: TokenDataContractAddressInclude;
};

export type TokenDataContractAddressInclude =
  (typeof TokenDataContractAddressInclude)[keyof typeof TokenDataContractAddressInclude];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenDataContractAddressInclude = {
  top_pools: "top_pools",
} as const;

export type TokensDataContractAddressesParams = {
  /**
   * attributes to include
   */
  include?: TokensDataContractAddressesInclude;
};

export type TokensDataContractAddressesInclude =
  (typeof TokensDataContractAddressesInclude)[keyof typeof TokensDataContractAddressesInclude];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokensDataContractAddressesInclude = {
  top_pools: "top_pools",
} as const;

export type TokensInfoRecentUpdatedParams = {
  /**
   * Attributes for related resources to include, which will be returned under the top-level 'included' key
   */
  include?: TokensInfoRecentUpdatedInclude;
  /**
   * filter tokens by provided network <br> *refers to [/networks](/reference/networks-list)
   */
  network?: string;
};

export type TokensInfoRecentUpdatedInclude =
  (typeof TokensInfoRecentUpdatedInclude)[keyof typeof TokensInfoRecentUpdatedInclude];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokensInfoRecentUpdatedInclude = {
  network: "network",
} as const;

export type TopTokenHoldersTokenAddressParams = {
  /**
   * number of top token holders to return, you may use any integer or `max` <br> Default value: 10
   */
  holders?: string;
};

export type PoolOhlcvContractAddressParams = {
  /**
   * time period to aggregate each OHLCV <br> Available values (day): `1` <br> Available values (hour): `1` , `4` , `12` <br> Available values (minute): `1` , `5` , `15` <br> Default value: 1
   */
  aggregate?: string;
  /**
   * return OHLCV data before this timestamp (integer seconds since epoch)
   */
  before_timestamp?: number;
  /**
   * number of OHLCV results to return, maximum 1000 <br> Default value: 100
   */
  limit?: number;
  /**
   * return OHLCV in USD or quote token <br> Default value: usd
   */
  currency?: PoolOhlcvContractAddressCurrency;
  /**
   * return OHLCV for token <br> use this to invert the chart <br> Available values: 'base', 'quote' or token address <br> Default value: 'base'
   */
  token?: string;
};

export type PoolOhlcvContractAddressCurrency =
  (typeof PoolOhlcvContractAddressCurrency)[keyof typeof PoolOhlcvContractAddressCurrency];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolOhlcvContractAddressCurrency = {
  usd: "usd",
  token: "token",
} as const;

export type PoolTradesContractAddressParams = {
  /**
   * filter trades by trade volume in USD greater than this value <br> Default value: 0
   */
  trade_volume_in_usd_greater_than?: number;
  /**
   * return trades for token <br> use this to invert the chart <br> Available values: 'base', 'quote' or token address <br> Default value: 'base'
   */
  token?: string;
};

export type CategoriesListParams = {
  /**
   * page through results <br> Default value: `1`
   */
  page?: number;
  /**
   * sort the categories by field <br> Default value: `h6_volume_percentage_desc`
   */
  sort?: CategoriesListSort;
};

export type CategoriesListSort =
  (typeof CategoriesListSort)[keyof typeof CategoriesListSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CategoriesListSort = {
  h1_volume_percentage_desc: "h1_volume_percentage_desc",
  h6_volume_percentage_desc: "h6_volume_percentage_desc",
  h12_volume_percentage_desc: "h12_volume_percentage_desc",
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
  fdv_usd_desc: "fdv_usd_desc",
  reserve_in_usd_desc: "reserve_in_usd_desc",
} as const;

export type PoolsCategoryParams = {
  /**
   * attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`
   */
  include?: string;
  /**
   * page through results <br> Default value: `1`
   */
  page?: number;
  /**
   * sort the pools by field <br> Default value: `pool_created_at_desc`
   */
  sort?: PoolsCategorySort;
};

export type PoolsCategorySort =
  (typeof PoolsCategorySort)[keyof typeof PoolsCategorySort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolsCategorySort = {
  m5_trending: "m5_trending",
  h1_trending: "h1_trending",
  h6_trending: "h6_trending",
  h24_trending: "h24_trending",
  h24_tx_count_desc: "h24_tx_count_desc",
  h24_volume_usd_desc: "h24_volume_usd_desc",
  pool_created_at_desc: "pool_created_at_desc",
  h24_price_change_percentage_desc: "h24_price_change_percentage_desc",
} as const;

/**
 * This endpoint allows you to **get token price based on the provided token contract address on a network**
 * @summary Token Price by Token Addresses
 */
export type onchainSimplePriceResponse200 = {
  data: OnchainSimplePrice;
  status: 200;
};

export type onchainSimplePriceResponseComposite = onchainSimplePriceResponse200;

export type onchainSimplePriceResponse = onchainSimplePriceResponseComposite & {
  headers: Headers;
};

export const getOnchainSimplePriceUrl = (
  network: string,
  addresses: string,
  params?: OnchainSimplePriceParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/simple/networks/${network}/token_price/${addresses}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/simple/networks/${network}/token_price/${addresses}`;
};

export const onchainSimplePrice = async (
  network: string,
  addresses: string,
  params?: OnchainSimplePriceParams,
  options?: RequestInit,
): Promise<onchainSimplePriceResponse> => {
  return request<onchainSimplePriceResponse>(
    getOnchainSimplePriceUrl(network, addresses, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query all the supported networks on GeckoTerminal**
 * @summary Supported Networks List (ID Map)
 */
export type networksListResponse200 = {
  data: NetworksList;
  status: 200;
};

export type networksListResponseComposite = networksListResponse200;

export type networksListResponse = networksListResponseComposite & {
  headers: Headers;
};

export const getNetworksListUrl = (params?: NetworksListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks`;
};

export const networksList = async (
  params?: NetworksListParams,
  options?: RequestInit,
): Promise<networksListResponse> => {
  return request<networksListResponse>(getNetworksListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query all the supported decentralized exchanges (DEXs) based on the provided network on GeckoTerminal**
 * @summary Supported Dexes List by Network (ID Map)
 */
export type dexesListResponse200 = {
  data: DexesList;
  status: 200;
};

export type dexesListResponseComposite = dexesListResponse200;

export type dexesListResponse = dexesListResponseComposite & {
  headers: Headers;
};

export const getDexesListUrl = (network: string, params?: DexesListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/dexes?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/dexes`;
};

export const dexesList = async (
  network: string,
  params?: DexesListParams,
  options?: RequestInit,
): Promise<dexesListResponse> => {
  return request<dexesListResponse>(getDexesListUrl(network, params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query all the trending pools across all networks on GeckoTerminal**
 * @summary Trending Pools List
 */
export type trendingPoolsListResponse200 = {
  data: Pool;
  status: 200;
};

export type trendingPoolsListResponseComposite = trendingPoolsListResponse200;

export type trendingPoolsListResponse = trendingPoolsListResponseComposite & {
  headers: Headers;
};

export const getTrendingPoolsListUrl = (params?: TrendingPoolsListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/trending_pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/trending_pools`;
};

export const trendingPoolsList = async (
  params?: TrendingPoolsListParams,
  options?: RequestInit,
): Promise<trendingPoolsListResponse> => {
  return request<trendingPoolsListResponse>(getTrendingPoolsListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query the trending pools based on the provided network**
 * @summary Trending Pools by Network
 */
export type trendingPoolsNetworkResponse200 = {
  data: Pool;
  status: 200;
};

export type trendingPoolsNetworkResponseComposite =
  trendingPoolsNetworkResponse200;

export type trendingPoolsNetworkResponse =
  trendingPoolsNetworkResponseComposite & {
    headers: Headers;
  };

export const getTrendingPoolsNetworkUrl = (
  network: string,
  params?: TrendingPoolsNetworkParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/trending_pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/trending_pools`;
};

export const trendingPoolsNetwork = async (
  network: string,
  params?: TrendingPoolsNetworkParams,
  options?: RequestInit,
): Promise<trendingPoolsNetworkResponse> => {
  return request<trendingPoolsNetworkResponse>(
    getTrendingPoolsNetworkUrl(network, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query the specific pool based on the provided network and pool address**
 * @summary Specific Pool Data by Pool Address
 */
export type poolAddressResponse200 = {
  data: PoolInfo;
  status: 200;
};

export type poolAddressResponseComposite = poolAddressResponse200;

export type poolAddressResponse = poolAddressResponseComposite & {
  headers: Headers;
};

export const getPoolAddressUrl = (
  network: string,
  address: string,
  params?: PoolAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${address}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${address}`;
};

export const poolAddress = async (
  network: string,
  address: string,
  params?: PoolAddressParams,
  options?: RequestInit,
): Promise<poolAddressResponse> => {
  return request<poolAddressResponse>(
    getPoolAddressUrl(network, address, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query multiple pools based on the provided network and pool address**
 * @summary Multiple Pools Data by Pool Addresses
 */
export type poolsAddressesResponse200 = {
  data: PoolInfo;
  status: 200;
};

export type poolsAddressesResponseComposite = poolsAddressesResponse200;

export type poolsAddressesResponse = poolsAddressesResponseComposite & {
  headers: Headers;
};

export const getPoolsAddressesUrl = (
  network: string,
  addresses: string,
  params?: PoolsAddressesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/multi/${addresses}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/multi/${addresses}`;
};

export const poolsAddresses = async (
  network: string,
  addresses: string,
  params?: PoolsAddressesParams,
  options?: RequestInit,
): Promise<poolsAddressesResponse> => {
  return request<poolsAddressesResponse>(
    getPoolsAddressesUrl(network, addresses, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query all the top pools based on the provided network**
 * @summary Top Pools by Network
 */
export type topPoolsNetworkResponse200 = {
  data: Pool;
  status: 200;
};

export type topPoolsNetworkResponseComposite = topPoolsNetworkResponse200;

export type topPoolsNetworkResponse = topPoolsNetworkResponseComposite & {
  headers: Headers;
};

export const getTopPoolsNetworkUrl = (
  network: string,
  params?: TopPoolsNetworkParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools`;
};

export const topPoolsNetwork = async (
  network: string,
  params?: TopPoolsNetworkParams,
  options?: RequestInit,
): Promise<topPoolsNetworkResponse> => {
  return request<topPoolsNetworkResponse>(
    getTopPoolsNetworkUrl(network, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query all the top pools based on the provided network and decentralized exchange (DEX)**
 * @summary Top Pools by Dex
 */
export type topPoolsDexResponse200 = {
  data: Pool;
  status: 200;
};

export type topPoolsDexResponseComposite = topPoolsDexResponse200;

export type topPoolsDexResponse = topPoolsDexResponseComposite & {
  headers: Headers;
};

export const getTopPoolsDexUrl = (
  network: string,
  dex: string,
  params?: TopPoolsDexParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/dexes/${dex}/pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/dexes/${dex}/pools`;
};

export const topPoolsDex = async (
  network: string,
  dex: string,
  params?: TopPoolsDexParams,
  options?: RequestInit,
): Promise<topPoolsDexResponse> => {
  return request<topPoolsDexResponse>(getTopPoolsDexUrl(network, dex, params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query all the latest pools based on provided network**
 * @summary New Pools by Network
 */
export type latestPoolsNetworkResponse200 = {
  data: Pool;
  status: 200;
};

export type latestPoolsNetworkResponseComposite = latestPoolsNetworkResponse200;

export type latestPoolsNetworkResponse = latestPoolsNetworkResponseComposite & {
  headers: Headers;
};

export const getLatestPoolsNetworkUrl = (
  network: string,
  params?: LatestPoolsNetworkParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/new_pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/new_pools`;
};

export const latestPoolsNetwork = async (
  network: string,
  params?: LatestPoolsNetworkParams,
  options?: RequestInit,
): Promise<latestPoolsNetworkResponse> => {
  return request<latestPoolsNetworkResponse>(
    getLatestPoolsNetworkUrl(network, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query all the latest pools across all networks on GeckoTerminal**
 * @summary New Pools List
 */
export type latestPoolsListResponse200 = {
  data: Pool;
  status: 200;
};

export type latestPoolsListResponseComposite = latestPoolsListResponse200;

export type latestPoolsListResponse = latestPoolsListResponseComposite & {
  headers: Headers;
};

export const getLatestPoolsListUrl = (params?: LatestPoolsListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/new_pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/new_pools`;
};

export const latestPoolsList = async (
  params?: LatestPoolsListParams,
  options?: RequestInit,
): Promise<latestPoolsListResponse> => {
  return request<latestPoolsListResponse>(getLatestPoolsListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query pools based on various filters across all networks on GeckoTerminal**
 * @summary üî• Megafilter for Pools
 */
export type poolsMegafilterResponse200 = {
  data: Pool;
  status: 200;
};

export type poolsMegafilterResponseComposite = poolsMegafilterResponse200;

export type poolsMegafilterResponse = poolsMegafilterResponseComposite & {
  headers: Headers;
};

export const getPoolsMegafilterUrl = (params?: PoolsMegafilterParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/pools/megafilter?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/pools/megafilter`;
};

export const poolsMegafilter = async (
  params?: PoolsMegafilterParams,
  options?: RequestInit,
): Promise<poolsMegafilterResponse> => {
  return request<poolsMegafilterResponse>(getPoolsMegafilterUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **search for pools on a network**
 * @summary Search Pools
 */
export type searchPoolsResponse200 = {
  data: Pool;
  status: 200;
};

export type searchPoolsResponseComposite = searchPoolsResponse200;

export type searchPoolsResponse = searchPoolsResponseComposite & {
  headers: Headers;
};

export const getSearchPoolsUrl = (params?: SearchPoolsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/search/pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/search/pools`;
};

export const searchPools = async (
  params?: SearchPoolsParams,
  options?: RequestInit,
): Promise<searchPoolsResponse> => {
  return request<searchPoolsResponse>(getSearchPoolsUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query all the trending search pools across all networks on GeckoTerminal**
 * @summary Trending Search Pools
 */
export type trendingSearchPoolsResponse200 = {
  data: TrendingPools;
  status: 200;
};

export type trendingSearchPoolsResponseComposite =
  trendingSearchPoolsResponse200;

export type trendingSearchPoolsResponse =
  trendingSearchPoolsResponseComposite & {
    headers: Headers;
  };

export const getTrendingSearchPoolsUrl = (
  params?: TrendingSearchPoolsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/pools/trending_search?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/pools/trending_search`;
};

export const trendingSearchPools = async (
  params?: TrendingSearchPoolsParams,
  options?: RequestInit,
): Promise<trendingSearchPoolsResponse> => {
  return request<trendingSearchPoolsResponse>(
    getTrendingSearchPoolsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query top pools based on the provided token contract address on a network**
 * @summary Top Pools by Token Address
 */
export type topPoolsContractAddressResponse200 = {
  data: Pool;
  status: 200;
};

export type topPoolsContractAddressResponseComposite =
  topPoolsContractAddressResponse200;

export type topPoolsContractAddressResponse =
  topPoolsContractAddressResponseComposite & {
    headers: Headers;
  };

export const getTopPoolsContractAddressUrl = (
  network: string,
  tokenAddress: string,
  params?: TopPoolsContractAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${tokenAddress}/pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${tokenAddress}/pools`;
};

export const topPoolsContractAddress = async (
  network: string,
  tokenAddress: string,
  params?: TopPoolsContractAddressParams,
  options?: RequestInit,
): Promise<topPoolsContractAddressResponse> => {
  return request<topPoolsContractAddressResponse>(
    getTopPoolsContractAddressUrl(network, tokenAddress, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query specific token data based on the provided token contract address on a network**
 * @summary Token Data by Token Address
 */
export type tokenDataContractAddressResponse200 = {
  data: Token;
  status: 200;
};

export type tokenDataContractAddressResponseComposite =
  tokenDataContractAddressResponse200;

export type tokenDataContractAddressResponse =
  tokenDataContractAddressResponseComposite & {
    headers: Headers;
  };

export const getTokenDataContractAddressUrl = (
  network: string,
  address: string,
  params?: TokenDataContractAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${address}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${address}`;
};

export const tokenDataContractAddress = async (
  network: string,
  address: string,
  params?: TokenDataContractAddressParams,
  options?: RequestInit,
): Promise<tokenDataContractAddressResponse> => {
  return request<tokenDataContractAddressResponse>(
    getTokenDataContractAddressUrl(network, address, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query multiple tokens data based on the provided token contract addresses on a network**
 * @summary Tokens Data by Token Addresses
 */
export type tokensDataContractAddressesResponse200 = {
  data: Token;
  status: 200;
};

export type tokensDataContractAddressesResponseComposite =
  tokensDataContractAddressesResponse200;

export type tokensDataContractAddressesResponse =
  tokensDataContractAddressesResponseComposite & {
    headers: Headers;
  };

export const getTokensDataContractAddressesUrl = (
  network: string,
  addresses: string,
  params?: TokensDataContractAddressesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/multi/${addresses}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/multi/${addresses}`;
};

export const tokensDataContractAddresses = async (
  network: string,
  addresses: string,
  params?: TokensDataContractAddressesParams,
  options?: RequestInit,
): Promise<tokensDataContractAddressesResponse> => {
  return request<tokensDataContractAddressesResponse>(
    getTokensDataContractAddressesUrl(network, addresses, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query token metadata (name, symbol,  CoinGecko ID, image, socials, websites, description, etc.) based on a provided token contract address on a network**
 * @summary Token Info by Token Address
 */
export type tokenInfoContractAddressResponse200 = {
  data: TokenInfo;
  status: 200;
};

export type tokenInfoContractAddressResponseComposite =
  tokenInfoContractAddressResponse200;

export type tokenInfoContractAddressResponse =
  tokenInfoContractAddressResponseComposite & {
    headers: Headers;
  };

export const getTokenInfoContractAddressUrl = (
  network: string,
  address: string,
) => {
  return `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${address}/info`;
};

export const tokenInfoContractAddress = async (
  network: string,
  address: string,
  options?: RequestInit,
): Promise<tokenInfoContractAddressResponse> => {
  return request<tokenInfoContractAddressResponse>(
    getTokenInfoContractAddressUrl(network, address),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query pool metadata (base and quote token details, image, socials, websites, description, contract address, etc.) based on a provided pool contract address on a network**
 * @summary Pool Tokens Info by Pool Address
 */
export type poolTokenInfoContractAddressResponse200 = {
  data: PoolTokensInfo;
  status: 200;
};

export type poolTokenInfoContractAddressResponseComposite =
  poolTokenInfoContractAddressResponse200;

export type poolTokenInfoContractAddressResponse =
  poolTokenInfoContractAddressResponseComposite & {
    headers: Headers;
  };

export const getPoolTokenInfoContractAddressUrl = (
  network: string,
  poolAddress: string,
) => {
  return `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${poolAddress}/info`;
};

export const poolTokenInfoContractAddress = async (
  network: string,
  poolAddress: string,
  options?: RequestInit,
): Promise<poolTokenInfoContractAddressResponse> => {
  return request<poolTokenInfoContractAddressResponse>(
    getPoolTokenInfoContractAddressUrl(network, poolAddress),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query 100 most recently updated tokens info of a specific network or across all networks on GeckoTerminal**
 * @summary Most Recently Updated Tokens List
 */
export type tokensInfoRecentUpdatedResponse200 = {
  data: TokenInfoRecentlyUpdated;
  status: 200;
};

export type tokensInfoRecentUpdatedResponseComposite =
  tokensInfoRecentUpdatedResponse200;

export type tokensInfoRecentUpdatedResponse =
  tokensInfoRecentUpdatedResponseComposite & {
    headers: Headers;
  };

export const getTokensInfoRecentUpdatedUrl = (
  params?: TokensInfoRecentUpdatedParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/tokens/info_recently_updated?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/tokens/info_recently_updated`;
};

export const tokensInfoRecentUpdated = async (
  params?: TokensInfoRecentUpdatedParams,
  options?: RequestInit,
): Promise<tokensInfoRecentUpdatedResponse> => {
  return request<tokensInfoRecentUpdatedResponse>(
    getTokensInfoRecentUpdatedUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query top token holders based on the provided token contract address on a network**
 * @summary Top Token Holders by Token Address
 */
export type topTokenHoldersTokenAddressResponse200 = {
  data: TokenHolder;
  status: 200;
};

export type topTokenHoldersTokenAddressResponseComposite =
  topTokenHoldersTokenAddressResponse200;

export type topTokenHoldersTokenAddressResponse =
  topTokenHoldersTokenAddressResponseComposite & {
    headers: Headers;
  };

export const getTopTokenHoldersTokenAddressUrl = (
  network: string,
  address: string,
  params?: TopTokenHoldersTokenAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${address}/top_holders?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/tokens/${address}/top_holders`;
};

export const topTokenHoldersTokenAddress = async (
  network: string,
  address: string,
  params?: TopTokenHoldersTokenAddressParams,
  options?: RequestInit,
): Promise<topTokenHoldersTokenAddressResponse> => {
  return request<topTokenHoldersTokenAddressResponse>(
    getTopTokenHoldersTokenAddressUrl(network, address, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **get the OHLCV chart (Open, High, Low, Close, Volume) of a pool based on the provided pool address on a network**
 * @summary Pool OHLCV chart by Pool Address
 */
export type poolOhlcvContractAddressResponse200 = {
  data: Ohlcv;
  status: 200;
};

export type poolOhlcvContractAddressResponseComposite =
  poolOhlcvContractAddressResponse200;

export type poolOhlcvContractAddressResponse =
  poolOhlcvContractAddressResponseComposite & {
    headers: Headers;
  };

export const getPoolOhlcvContractAddressUrl = (
  network: string,
  poolAddress: string,
  timeframe: "day" | "hour" | "minute",
  params?: PoolOhlcvContractAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`;
};

export const poolOhlcvContractAddress = async (
  network: string,
  poolAddress: string,
  timeframe: "day" | "hour" | "minute",
  params?: PoolOhlcvContractAddressParams,
  options?: RequestInit,
): Promise<poolOhlcvContractAddressResponse> => {
  return request<poolOhlcvContractAddressResponse>(
    getPoolOhlcvContractAddressUrl(network, poolAddress, timeframe, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query the last 300 trades in the past 24 hours based on the provided pool address**
 * @summary Past 24 Hour Trades by Pool Address
 */
export type poolTradesContractAddressResponse200 = {
  data: Trades;
  status: 200;
};

export type poolTradesContractAddressResponseComposite =
  poolTradesContractAddressResponse200;

export type poolTradesContractAddressResponse =
  poolTradesContractAddressResponseComposite & {
    headers: Headers;
  };

export const getPoolTradesContractAddressUrl = (
  network: string,
  poolAddress: string,
  params?: PoolTradesContractAddressParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${poolAddress}/trades?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/networks/${network}/pools/${poolAddress}/trades`;
};

export const poolTradesContractAddress = async (
  network: string,
  poolAddress: string,
  params?: PoolTradesContractAddressParams,
  options?: RequestInit,
): Promise<poolTradesContractAddressResponse> => {
  return request<poolTradesContractAddressResponse>(
    getPoolTradesContractAddressUrl(network, poolAddress, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * This endpoint allows you to **query all the supported categories on GeckoTerminal**
 * @summary Categories List
 */
export type categoriesListResponse200 = {
  data: OnchainCategoriesList;
  status: 200;
};

export type categoriesListResponseComposite = categoriesListResponse200;

export type categoriesListResponse = categoriesListResponseComposite & {
  headers: Headers;
};

export const getCategoriesListUrl = (params?: CategoriesListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/categories?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/categories`;
};

export const categoriesList = async (
  params?: CategoriesListParams,
  options?: RequestInit,
): Promise<categoriesListResponse> => {
  return request<categoriesListResponse>(getCategoriesListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint allows you to **query all the pools based on the provided category ID**
 * @summary Pools by Category ID
 */
export type poolsCategoryResponse200 = {
  data: CategoriesPools;
  status: 200;
};

export type poolsCategoryResponseComposite = poolsCategoryResponse200;

export type poolsCategoryResponse = poolsCategoryResponseComposite & {
  headers: Headers;
};

export const getPoolsCategoryUrl = (
  categoryId: string,
  params?: PoolsCategoryParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://pro-api.coingecko.com/api/v3/onchain/categories/${categoryId}/pools?${stringifiedParams}`
    : `https://pro-api.coingecko.com/api/v3/onchain/categories/${categoryId}/pools`;
};

export const poolsCategory = async (
  categoryId: string,
  params?: PoolsCategoryParams,
  options?: RequestInit,
): Promise<poolsCategoryResponse> => {
  return request<poolsCategoryResponse>(
    getPoolsCategoryUrl(categoryId, params),
    {
      ...options,
      method: "GET",
    },
  );
};
